diff --git a/bazel/BUILD b/bazel/BUILD
index cb3135c..4d6d92c 100644
--- a/bazel/BUILD
+++ b/bazel/BUILD
@@ -61,35 +61,47 @@ alias(
         ":linux_arm64": "@emscripten_bin_linux_arm64//:linker_files",
         ":macos": "@emscripten_bin_mac//:linker_files",
         ":macos_arm64": "@emscripten_bin_mac_arm64//:linker_files",
         ":windows": "@emscripten_bin_win//:linker_files",
         "//conditions:default": ":empty",
     }),
 )
 
 alias(
     name = "ar_files",
     actual = select({
         ":linux": "@emscripten_bin_linux//:ar_files",
         ":linux_arm64": "@emscripten_bin_linux_arm64//:ar_files",
         ":macos": "@emscripten_bin_mac//:ar_files",
         ":macos_arm64": "@emscripten_bin_mac_arm64//:ar_files",
         ":windows": "@emscripten_bin_win//:ar_files",
         "//conditions:default": ":empty",
     }),
 )
 
+alias(
+    name = "dwp_files",
+    actual = select({
+        ":linux": "@emscripten_bin_linux//:dwp_files",
+        ":linux_arm64": "@emscripten_bin_linux_arm64//:dwp_files",
+        ":macos": "@emscripten_bin_mac//:dwp_files",
+        ":macos_arm64": "@emscripten_bin_mac_arm64//:dwp_files",
+        ":windows": "@emscripten_bin_win//:dwp_files",
+        "//conditions:default": ":empty",
+    }),
+)
+
 platform(
     name = "platform_wasm",
     constraint_values = [
         "@platforms//cpu:wasm32",
         "@platforms//os:emscripten",
     ],
 )
 
 platform(
     name = "platform_wasi",
     constraint_values = [
         "@platforms//cpu:wasm32",
         "@platforms//os:wasi",
     ],
 )
diff --git a/bazel/emscripten_deps.bzl b/bazel/emscripten_deps.bzl
index 9d020bd..f466edb 100644
--- a/bazel/emscripten_deps.bzl
+++ b/bazel/emscripten_deps.bzl
@@ -79,40 +79,47 @@ filegroup(
     ),
 )
 
 filegroup(
     name = "ar_files",
     srcs = [
         "bin/llvm-ar{bin_extension}",
         "emscripten/emar.py",
         "emscripten/emscripten-version.txt",
         "emscripten/src/settings.js",
         "emscripten/src/settings_internal.js",
     ] + glob(
         include = [
             "emscripten/tools/**",
         ],
         exclude = [
             "**/__pycache__/**",
         ],
     ),
 )
+
+filegroup(
+    name = "dwp_files",
+    srcs = [
+        "bin/llvm-dwp{bin_extension}",
+    ],
+)
 """
 
 def emscripten_deps(emscripten_version = "latest"):
     version = emscripten_version
 
     if version == "latest":
         version = reversed(sorted(EMSCRIPTEN_TAGS.keys(), key = _parse_version))[0]
 
     if version not in EMSCRIPTEN_TAGS.keys():
         error_msg = "Emscripten version {} not found.".format(version)
         error_msg += " Look at @emsdk//:revisions.bzl for the list "
         error_msg += "of currently supported versions."
         fail(error_msg)
 
     revision = EMSCRIPTEN_TAGS[version]
 
     emscripten_url = "https://storage.googleapis.com/webassembly/emscripten-releases-builds/{}/{}/wasm-binaries{}.{}"
 
     # This could potentially backfire for projects with multiple emscripten
     # dependencies that use different emscripten versions
@@ -156,55 +163,20 @@ def emscripten_deps(emscripten_version = "latest"):
 
     if "emscripten_bin_mac_arm64" not in excludes:
         http_archive(
             name = "emscripten_bin_mac_arm64",
             strip_prefix = "install",
             url = emscripten_url.format("mac", revision.hash, "-arm64", "tar.xz"),
             sha256 = revision.sha_mac_arm64,
             build_file_content = BUILD_FILE_CONTENT_TEMPLATE.format(bin_extension = ""),
             type = "tar.xz",
         )
 
     if "emscripten_bin_win" not in excludes:
         http_archive(
             name = "emscripten_bin_win",
             strip_prefix = "install",
             url = emscripten_url.format("win", revision.hash, "", "zip"),
             sha256 = revision.sha_win,
             build_file_content = BUILD_FILE_CONTENT_TEMPLATE.format(bin_extension = ".exe"),
             type = "zip",
         )
-
-    if "emscripten_npm_linux" not in excludes:
-        npm_translate_lock(
-            name = "emscripten_npm_linux",
-            data = ["@emscripten_bin_linux//:emscripten/package.json"],
-            npm_package_lock = "@emscripten_bin_linux//:emscripten/package-lock.json",
-        )
-
-    if "emscripten_npm_linux_arm64" not in excludes:
-        npm_translate_lock(
-            name = "emscripten_npm_linux_arm64",
-            data = ["@emscripten_bin_linux_arm64//:emscripten/package.json"],
-            npm_package_lock = "@emscripten_bin_linux_arm64//:emscripten/package-lock.json",
-        )
-
-    if "emscripten_npm_mac" not in excludes:
-        npm_translate_lock(
-            name = "emscripten_npm_mac",
-            data = ["@emscripten_bin_mac//:emscripten/package.json"],
-            npm_package_lock = "@emscripten_bin_mac//:emscripten/package-lock.json",
-        )
-
-    if "emscripten_npm_mac_arm64" not in excludes:
-        npm_translate_lock(
-            name = "emscripten_npm_mac",
-            data = ["@emscripten_bin_mac_arm64//:emscripten/package.json"],
-            npm_package_lock = "@emscripten_bin_mac_arm64//:emscripten/package-lock.json",
-        )
-
-    if "emscripten_npm_win" not in excludes:
-        npm_translate_lock(
-            name = "emscripten_npm_win",
-            data = ["@emscripten_bin_win//:emscripten/package.json"],
-            npm_package_lock = "@emscripten_bin_win//:emscripten/package-lock.json",
-        )
diff --git a/bazel/emscripten_toolchain/BUILD.bazel b/bazel/emscripten_toolchain/BUILD.bazel
index a989450..08d0fab 100644
--- a/bazel/emscripten_toolchain/BUILD.bazel
+++ b/bazel/emscripten_toolchain/BUILD.bazel
@@ -1,98 +1,113 @@
+load("@python3_12//:defs.bzl", "py_binary")
 load(":toolchain.bzl", "emscripten_cc_toolchain_config_rule")
 
 package(default_visibility = ["//visibility:public"])
 
 filegroup(
     name = "common_files",
     srcs = [
         "@emscripten_cache//:emscripten_config",
         "env.sh",
         "env.bat",
         "@nodejs//:node_files",
+        "@python3_12//:python3",
     ],
 )
 
 filegroup(
     name = "compiler_files",
     srcs = [
         "emcc.sh",
         "emcc.bat",
         "@emsdk//:compiler_files",
         ":common_files",
     ],
 )
 
 filegroup(
     name = "linker_files",
     srcs = [
         "emcc_link.sh",
         "emcc_link.bat",
         "link_wrapper.py",
         "@emsdk//:linker_files",
         ":common_files",
     ],
 )
 
 filegroup(
     name = "ar_files",
     srcs = [
         "emar.sh",
         "emar.bat",
         "@emsdk//:ar_files",
         ":common_files",
     ],
 )
 
+filegroup(
+    name = "dwp_files",
+    srcs = [
+        "emdwp-emscripten_bin_linux_arm64.sh",
+        "emdwp-emscripten_bin_linux.sh",
+        "emdwp-emscripten_bin_mac_arm64.sh",
+        "emdwp-emscripten_bin_mac.sh",
+        "emdwp-emscripten_bin_win.bat",
+        "@emsdk//:dwp_files",
+    ],
+)
+
 filegroup(
     name = "all_files",
     srcs = [
         ":ar_files",
         ":compiler_files",
         ":linker_files",
+        ":dwp_files",
     ],
 )
 
 filegroup(name = "empty")
 
 # dlmalloc.bc is implicitly added by the emscripten toolchain
 cc_library(name = "malloc")
 
 emscripten_cc_toolchain_config_rule(
     name = "wasm",
     cpu = "wasm",
     em_config = "@emscripten_cache//:emscripten_config",
     emscripten_binaries = "@emsdk//:compiler_files",
     nodejs_bin = "@nodejs//:node",
-    script_extension = select({
-        "@bazel_tools//src/conditions:host_windows": "bat",
-        "//conditions:default": "sh",
+    is_windows = select({
+        "@bazel_tools//src/conditions:host_windows": True,
+        "//conditions:default": False,
     }),
 )
 
 cc_toolchain(
     name = "cc-compiler-wasm",
     all_files = ":all_files",
     ar_files = ":ar_files",
     as_files = ":empty",
     compiler_files = ":compiler_files",
-    dwp_files = ":empty",
+    dwp_files = ":dwp_files",
     linker_files = ":linker_files",
     objcopy_files = ":empty",
     strip_files = ":empty",
     toolchain_config = "wasm",
     toolchain_identifier = "emscripten-wasm",
 )
 
 cc_toolchain_suite(
     name = "everything",
     toolchains = {
         "wasm": ":cc-compiler-wasm",
         "wasm|emscripten": ":cc-compiler-wasm",
     },
 )
 
 toolchain(
     name = "cc-toolchain-wasm",
     target_compatible_with = ["@platforms//cpu:wasm32"],
     toolchain = ":cc-compiler-wasm",
     toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
diff --git a/bazel/emscripten_toolchain/dwp.bat b/bazel/emscripten_toolchain/dwp.bat
new file mode 100644
index 0000000..85ed4b5
--- /dev/null
+++ b/bazel/emscripten_toolchain/dwp.bat
@@ -0,0 +1,4 @@
+@echo off
+REM Dummy dwp script for emscripten toolchain
+REM Since wasm doesn't support split debug info, this is a no-op
+exit /b 0
diff --git a/bazel/emscripten_toolchain/dwp.sh b/bazel/emscripten_toolchain/dwp.sh
new file mode 100644
index 0000000..50a1d80
--- /dev/null
+++ b/bazel/emscripten_toolchain/dwp.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# Dummy dwp script for emscripten toolchain
+# Since wasm doesn't support split debug info, this is a no-op
+# Just echo the command for debugging and exit successfully
+
+echo "DWP called with args: $@" >&2
+exit 0
diff --git a/bazel/emscripten_toolchain/emar.bat b/bazel/emscripten_toolchain/emar.bat
index b8e9125..844c378 100644
--- a/bazel/emscripten_toolchain/emar.bat
+++ b/bazel/emscripten_toolchain/emar.bat
@@ -1,5 +1,5 @@
 @ECHO OFF
 
 call external\emsdk\emscripten_toolchain\env.bat
 
-py -3 %EMSCRIPTEN%\emar.py %*
+%EMSDK_PYTHON% %EMSCRIPTEN%\emar.py %*
diff --git a/bazel/emscripten_toolchain/emar.sh b/bazel/emscripten_toolchain/emar.sh
index b4ead6e..7748cc7 100755
--- a/bazel/emscripten_toolchain/emar.sh
+++ b/bazel/emscripten_toolchain/emar.sh
@@ -1,5 +1,5 @@
 #!/bin/bash
 
 source $(dirname $0)/env.sh
 
-exec python3 $EMSCRIPTEN/emar.py "$@"
+exec $EMSDK_PYTHON $EMSCRIPTEN/emar.py "$@"
diff --git a/bazel/emscripten_toolchain/emcc.bat b/bazel/emscripten_toolchain/emcc.bat
index aba66f4..b302736 100644
--- a/bazel/emscripten_toolchain/emcc.bat
+++ b/bazel/emscripten_toolchain/emcc.bat
@@ -1,5 +1,5 @@
 @ECHO OFF
 
 call external\emsdk\emscripten_toolchain\env.bat
 
-py -3 %EMSCRIPTEN%\emcc.py %*
+%EMSDK_PYTHON% %EMSCRIPTEN%\emcc.py %*
diff --git a/bazel/emscripten_toolchain/emcc.sh b/bazel/emscripten_toolchain/emcc.sh
index 5fdaf9c..0cc4072 100755
--- a/bazel/emscripten_toolchain/emcc.sh
+++ b/bazel/emscripten_toolchain/emcc.sh
@@ -1,5 +1,11 @@
 #!/bin/bash
 
 source $(dirname $0)/env.sh
 
-exec python3 $EMSCRIPTEN/emcc.py "$@"
+$EMSDK_PYTHON --version >&2
+PYBINPATH="$(dirname "${EMSDK_PYTHON}")"
+export PATH=$PATH:$PYBINPATH
+
+python3 --version
+
+exec $EMSDK_PYTHON $EMSCRIPTEN/emcc.py "$@"
diff --git a/bazel/emscripten_toolchain/emcc_base.sh b/bazel/emscripten_toolchain/emcc_base.sh
new file mode 100755
index 0000000..e9ddd2c
--- /dev/null
+++ b/bazel/emscripten_toolchain/emcc_base.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+source $(dirname $0)/env.sh
+
+PYTHON3="${PYTHON3:-python3}"
+
+exec $PYTHON3 $EMSCRIPTEN/emcc.py "$@"
diff --git a/bazel/emscripten_toolchain/emcc_link.bat b/bazel/emscripten_toolchain/emcc_link.bat
index 8e5a6eb..fef6501 100644
--- a/bazel/emscripten_toolchain/emcc_link.bat
+++ b/bazel/emscripten_toolchain/emcc_link.bat
@@ -1,5 +1,5 @@
 @ECHO OFF
 
 call external\emsdk\emscripten_toolchain\env.bat
 
-py -3 external\emsdk\emscripten_toolchain\link_wrapper.py %*
+%EMSDK_PYTHON% external\emsdk\emscripten_toolchain\link_wrapper.py %*
diff --git a/bazel/emscripten_toolchain/emcc_link.sh b/bazel/emscripten_toolchain/emcc_link.sh
index 44f3235..e538915 100755
--- a/bazel/emscripten_toolchain/emcc_link.sh
+++ b/bazel/emscripten_toolchain/emcc_link.sh
@@ -1,5 +1,5 @@
 #!/bin/bash
 
 source $(dirname $0)/env.sh
 
-exec python3 $(dirname $0)/link_wrapper.py "$@"
+exec $EMSDK_PYTHON $(dirname $0)/link_wrapper.py "$@"
diff --git a/bazel/emscripten_toolchain/emdwp-emscripten_bin_linux.sh b/bazel/emscripten_toolchain/emdwp-emscripten_bin_linux.sh
new file mode 100755
index 0000000..513feee
--- /dev/null
+++ b/bazel/emscripten_toolchain/emdwp-emscripten_bin_linux.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+#
+#  This script differs in form from emcc.{py,bat}/…, because bazel are limited/bugged in the way of executing dwp tool.
+#  Bazel dwp action configuration does not pass environment variables, so we cannot use them in this script.
+#  For more info, see PR discussion and bazel issue:
+#  - https://github.com/emscripten-core/emsdk/pull/1531#discussion_r1962090650
+#  - https://github.com/bazelbuild/bazel/issues/25336
+#
+
+exec external/emscripten_bin_linux/bin/llvm-dwp "$@"
diff --git a/bazel/emscripten_toolchain/emdwp-emscripten_bin_linux_arm64.sh b/bazel/emscripten_toolchain/emdwp-emscripten_bin_linux_arm64.sh
new file mode 100755
index 0000000..f6f3383
--- /dev/null
+++ b/bazel/emscripten_toolchain/emdwp-emscripten_bin_linux_arm64.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+#
+#  This script differs in form from emcc.{py,bat}/…, because bazel are limited/bugged in the way of executing dwp tool.
+#  Bazel dwp action configuration does not pass environment variables, so we cannot use them in this script.
+#  For more info, see PR discussion and bazel issue:
+#  - https://github.com/emscripten-core/emsdk/pull/1531#discussion_r1962090650
+#  - https://github.com/bazelbuild/bazel/issues/25336
+#
+
+exec external/emscripten_bin_linux_arm64/bin/llvm-dwp "$@"
diff --git a/bazel/emscripten_toolchain/emdwp-emscripten_bin_mac.sh b/bazel/emscripten_toolchain/emdwp-emscripten_bin_mac.sh
new file mode 100755
index 0000000..0f97690
--- /dev/null
+++ b/bazel/emscripten_toolchain/emdwp-emscripten_bin_mac.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+#
+#  This script differs in form from emcc.{py,bat}/…, because bazel are limited/bugged in the way of executing dwp tool.
+#  Bazel dwp action configuration does not pass environment variables, so we cannot use them in this script.
+#  For more info, see PR discussion and bazel issue:
+#  - https://github.com/emscripten-core/emsdk/pull/1531#discussion_r1962090650
+#  - https://github.com/bazelbuild/bazel/issues/25336
+#
+
+exec external/emscripten_bin_mac/bin/llvm-dwp "$@"
diff --git a/bazel/emscripten_toolchain/emdwp-emscripten_bin_mac_arm64.sh b/bazel/emscripten_toolchain/emdwp-emscripten_bin_mac_arm64.sh
new file mode 100755
index 0000000..4ae033c
--- /dev/null
+++ b/bazel/emscripten_toolchain/emdwp-emscripten_bin_mac_arm64.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+#
+#  This script differs in form from emcc.{py,bat}/…, because bazel are limited/bugged in the way of executing dwp tool.
+#  Bazel dwp action configuration does not pass environment variables, so we cannot use them in this script.
+#  For more info, see PR discussion and bazel issue:
+#  - https://github.com/emscripten-core/emsdk/pull/1531#discussion_r1962090650
+#  - https://github.com/bazelbuild/bazel/issues/25336
+#
+
+exec external/emscripten_bin_mac_arm64/bin/llvm-dwp "$@"
diff --git a/bazel/emscripten_toolchain/emdwp-emscripten_bin_win.bat b/bazel/emscripten_toolchain/emdwp-emscripten_bin_win.bat
new file mode 100644
index 0000000..3cb1f2e
--- /dev/null
+++ b/bazel/emscripten_toolchain/emdwp-emscripten_bin_win.bat
@@ -0,0 +1,10 @@
+::
+::  This script differs in form from emcc.{py,bat}/…, because bazel are limited/bugged in the way of executing dwp tool.
+::  Bazel dwp action configuration does not pass environment variables, so we cannot use them in this script.
+::  For more info, see PR discussion and bazel issue:
+::  - https://github.com/emscripten-core/emsdk/pull/1531#discussion_r1962090650
+::  - https://github.com/bazelbuild/bazel/issues/25336
+::
+@ECHO OFF
+
+call external\emscripten_bin_win\bin\llvm-dwp %*
diff --git a/bazel/emscripten_toolchain/link_wrapper.py b/bazel/emscripten_toolchain/link_wrapper.py
index 6a6fe2f..6dcacf8 100644
--- a/bazel/emscripten_toolchain/link_wrapper.py
+++ b/bazel/emscripten_toolchain/link_wrapper.py
@@ -1,21 +1,20 @@
-#!/usr/bin/env python
 """wrapper around emcc link step.
 
 This wrapper currently serves the following purposes.
 
 1. When building with --config=wasm the final output is multiple files, usually
    at least one .js and one .wasm file. Since the cc_binary link step only
    allows a single output, we must tar up the outputs into a single file.
 
 2. Add quotes around arguments that need them in the response file to work
    around a bazel quirk.
 
 3. Ensure the external_debug_info section of the wasm points at the correct
    bazel path.
 """
 
 from __future__ import print_function
 
 import argparse
 import os
 import subprocess
diff --git a/bazel/emscripten_toolchain/toolchain.bzl b/bazel/emscripten_toolchain/toolchain.bzl
index c8cec07..b03a251 100644
--- a/bazel/emscripten_toolchain/toolchain.bzl
+++ b/bazel/emscripten_toolchain/toolchain.bzl
@@ -37,85 +37,94 @@ def flag_set(flags = None, features = None, not_features = None, **kwargs):
     """
     if flags:
         if kwargs.get("flag_groups"):
             fail("Cannot set flags and flag_groups")
         else:
             kwargs["flag_groups"] = [flag_group(flags = flags)]
 
     if features or not_features:
         if kwargs.get("with_features"):
             fail("Cannot set features/not_feature and with_features")
         kwargs["with_features"] = [with_feature_set(
             features = features or [],
             not_features = not_features or [],
         )]
     return _flag_set(**kwargs)
 
 CROSSTOOL_DEFAULT_WARNINGS = [
     "-Wall",
 ]
 
+def _os_path(ctx, path):
+    if ctx.attr.is_windows:
+        path = path.replace("/", "\\")
+    return path
+
 def _impl(ctx):
     target_cpu = ctx.attr.cpu
     toolchain_identifier = "emscripten-" + target_cpu
     target_system_name = target_cpu + "-unknown-emscripten"
 
     host_system_name = "i686-unknown-linux-gnu"
 
     target_libc = "musl/js"
 
     abi_version = "emscripten_syscalls"
 
     compiler = "emscripten"
     abi_libc_version = "default"
 
     cc_target_os = "emscripten"
 
     emscripten_dir = ctx.attr.emscripten_binaries.label.workspace_root
     nodejs_path = ctx.file.nodejs_bin.path
+    emscripten_name = ctx.attr.emscripten_binaries.label.workspace_name
 
     builtin_sysroot = emscripten_dir + "/emscripten/cache/sysroot"
 
-    emcc_script = "emcc.%s" % ctx.attr.script_extension
-    emcc_link_script = "emcc_link.%s" % ctx.attr.script_extension
-    emar_script = "emar.%s" % ctx.attr.script_extension
+    script_extension = "bat" if ctx.attr.is_windows else "sh"
+    emcc_script = "emcc.%s" % script_extension
+    emcc_link_script = "emcc_link.%s" % script_extension
+    emar_script = "emar.%s" % script_extension
+    emdwp_script = "emdwp-%s.%s" % (emscripten_name, script_extension)
 
     ################################################################
     # Tools
     ################################################################
     clang_tool = tool(path = emcc_script)
     clif_match_tool = tool(path = "dummy_clif_matcher")
     link_tool = tool(path = emcc_link_script)
     archive_tool = tool(path = emar_script)
     strip_tool = tool(path = "NOT_USED_STRIP_TOOL")
 
     #### Legacy tool paths (much of this is redundant with action_configs, but
     #### these are still used for some things)
     tool_paths = [
         tool_path(name = "ar", path = emar_script),
         tool_path(name = "cpp", path = "/bin/false"),
         tool_path(name = "gcc", path = emcc_script),
         tool_path(name = "gcov", path = "/bin/false"),
         tool_path(name = "ld", path = emcc_link_script),
         tool_path(name = "nm", path = "NOT_USED"),
         tool_path(name = "objdump", path = "/bin/false"),
         tool_path(name = "strip", path = "NOT_USED"),
+        tool_path(name = "dwp", path = emdwp_script),
     ]
 
     ################################################################
     # Action Configs
     ################################################################
 
     cpp_compile_action = action_config(
         action_name = ACTION_NAMES.cpp_compile,
         tools = [clang_tool],
     )
 
     cpp_module_compile_action = action_config(
         action_name = ACTION_NAMES.cpp_module_compile,
         tools = [clang_tool],
     )
 
     cpp_module_codegen_action = action_config(
         action_name = ACTION_NAMES.cpp_module_codegen,
         tools = [clang_tool],
     )
@@ -443,40 +452,83 @@ def _impl(ctx):
         feature(
             name = "precise_long_double_printf",
             enabled = True,
         ),
         feature(
             name = "wasm_warnings_as_errors",
             enabled = False,
         ),
 
         # ASan and UBSan. See also:
         # https://emscripten.org/docs/debugging/Sanitizers.html
         feature(name = "wasm_asan"),
         feature(name = "wasm_ubsan"),
         feature(
             name = "output_format_js",
             enabled = True,
         ),
         feature(
             name = "wasm_standalone",
         ),
+        # Support for debug fission. In short, debugging fission should:
+        #   * reduce linking time, RAM usage and disk usage
+        #   * speed up incremental builds
+        #   * speed up debugger work (reduce startup and breakpoint time)
+        # (to use this, follow the --fission=yes flag)
+        # https://developer.chrome.com/blog/faster-wasm-debugging
+        # https://bazel.build/docs/user-manual#fission
+        feature(
+            name = "per_object_debug_info",
+            flag_sets = [
+                flag_set(
+                    actions = [
+                        ACTION_NAMES.c_compile,
+                        ACTION_NAMES.cpp_compile,
+                        ACTION_NAMES.cpp_module_codegen,
+                        ACTION_NAMES.assemble,
+                        ACTION_NAMES.preprocess_assemble,
+                    ],
+                    flag_groups = [
+                        flag_group(
+                            flags = ["-g", "-gsplit-dwarf", "-gdwarf-5", "-gpubnames"],
+                            expand_if_available = "per_object_debug_info_file",
+                        ),
+                    ],
+                ),
+            ],
+            enabled = True,
+        ),
+        feature(
+            name = "fission_support",
+            flag_sets = [
+                flag_set(
+                    actions = all_link_actions,
+                    flag_groups = [
+                        flag_group(
+                            flags = ["-sWASM_BIGINT"], # WASM_BIGINT required to support dwarf-5
+                            expand_if_available = "is_using_fission",
+                        ),
+                    ],
+                ),
+            ],
+            enabled = True,
+        )
     ]
 
     crosstool_default_flag_sets = [
         # Compile, Link, and CC_FLAGS make variable
         flag_set(
             actions = [
                 ACTION_NAMES.c_compile,
                 ACTION_NAMES.cpp_compile,
                 ACTION_NAMES.linkstamp_compile,
                 ACTION_NAMES.assemble,
                 ACTION_NAMES.preprocess_assemble,
                 ACTION_NAMES.cpp_header_parsing,
                 ACTION_NAMES.cpp_module_compile,
                 ACTION_NAMES.cpp_module_codegen,
                 ACTION_NAMES.clif_match,
                 ACTION_NAMES.cpp_link_executable,
                 ACTION_NAMES.cpp_link_dynamic_library,
                 ACTION_NAMES.cpp_link_nodeps_dynamic_library,
             ],
             flag_groups = [
@@ -1048,40 +1100,44 @@ def _impl(ctx):
 
     crosstool_default_env_sets = [
         # Globals
         env_set(
             actions = all_compile_actions +
                       all_link_actions +
                       [ACTION_NAMES.cpp_link_static_library],
             env_entries = [
                 env_entry(
                     key = "EM_BIN_PATH",
                     value = emscripten_dir,
                 ),
                 env_entry(
                     key = "EM_CONFIG_PATH",
                     value = ctx.file.em_config.path,
                 ),
                 env_entry(
                     key = "NODE_JS_PATH",
                     value = nodejs_path,
                 ),
+                env_entry(
+                    key = "EMSDK_PYTHON",
+                    value = _os_path(ctx, ctx.file._python_interpreter.path),
+                ),
             ],
         ),
         # Use llvm backend.  Off by default, enabled via --features=llvm_backend
         env_set(
             actions = all_compile_actions +
                       all_link_actions +
                       [ACTION_NAMES.cpp_link_static_library],
             env_entries = [env_entry(key = "EMCC_WASM_BACKEND", value = "1")],
             with_features = [with_feature_set(features = ["llvm_backend"])],
         ),
         # Debug compile and link. Off by default, enabled via --features=emcc_debug
         env_set(
             actions = all_compile_actions,
             env_entries = [env_entry(key = "EMCC_DEBUG", value = "1")],
             with_features = [with_feature_set(features = ["emcc_debug"])],
         ),
 
         # Debug only link step. Off by default, enabled via --features=emcc_debug_link
         env_set(
             actions = all_link_actions,
@@ -1123,24 +1179,25 @@ def _impl(ctx):
         host_system_name = host_system_name,
         target_system_name = target_system_name,
         target_cpu = target_cpu,
         target_libc = target_libc,
         compiler = compiler,
         abi_version = abi_version,
         abi_libc_version = abi_libc_version,
         tool_paths = tool_paths,
         make_variables = make_variables,
         builtin_sysroot = builtin_sysroot,
         cc_target_os = cc_target_os,
     )
 
 emscripten_cc_toolchain_config_rule = rule(
     implementation = _impl,
     attrs = {
         "cpu": attr.string(mandatory = True, values = ["asmjs", "wasm"]),
         "em_config": attr.label(mandatory = True, allow_single_file = True),
         "emscripten_binaries": attr.label(mandatory = True, cfg = "exec"),
         "nodejs_bin": attr.label(mandatory = True, allow_single_file = True),
-        "script_extension": attr.string(mandatory = True, values = ["sh", "bat"]),
+        "is_windows": attr.bool(mandatory = True),
+        "_python_interpreter": attr.label(allow_single_file = True, cfg = "exec", default = Label("@python3_12//:python3")),
     },
     provides = [CcToolchainConfigInfo],
 )
diff --git a/bazel/emscripten_toolchain/wasm_binary.py b/bazel/emscripten_toolchain/wasm_binary.py
index d7d6142..0da7f55 100644
--- a/bazel/emscripten_toolchain/wasm_binary.py
+++ b/bazel/emscripten_toolchain/wasm_binary.py
@@ -1,53 +1,63 @@
 """Unpackages a bazel emscripten archive for use in a bazel BUILD rule.
 
 This script will take a tar archive containing the output of the emscripten
 toolchain. This file contains any output files produced by a wasm_cc_binary or a
 cc_binary built with --config=wasm. The files are extracted into the given
 output paths.
 
 The contents of the archive are expected to match the given outputs extnames.
 
 This script and its accompanying Bazel rule should allow you to extract a
 WebAssembly binary into a larger web application.
 """
 
 import argparse
 import os
 import tarfile
+import shutil
 
 
 def ensure(f):
   if not os.path.exists(f):
     with open(f, 'w'):
       pass
 
 
 def main():
   parser = argparse.ArgumentParser()
   parser.add_argument('--archive', help='The archive to extract from.')
   parser.add_argument('--outputs', help='Comma separated list of files that should be extracted from the archive. Only the extname has to match a file in the archive.')
+  parser.add_argument('--dwp_file', help='Optional dwp input file, generated when fission flags set.')
   parser.add_argument('--allow_empty_outputs', help='If an output listed in --outputs does not exist, create it anyways.', action='store_true')
   args = parser.parse_args()
 
   args.archive = os.path.normpath(args.archive)
   args.outputs = args.outputs.split(",")
+  args.dwp_file = os.path.normpath(args.dwp_file) if args.dwp_file else None
+
+  if args.dwp_file:
+    for idx, output in enumerate(args.outputs):
+      if output.endswith(".dwp"):  # also update extension 'binary.dwp' to 'binary.wasm.dwp'
+        shutil.copy2(args.dwp_file, output)
+        args.outputs.pop(idx)
+        break
 
   tar = tarfile.open(args.archive)
 
   for member in tar.getmembers():
     extname = '.' + member.name.split('.', 1)[1]
     for idx, output in enumerate(args.outputs):
       if output.endswith(extname):
         member_file = tar.extractfile(member)
         with open(output, "wb") as output_file:
           output_file.write(member_file.read())
         args.outputs.pop(idx)
         break
 
   for output in args.outputs:
     extname = '.' + output.split('.', 1)[1]
     if args.allow_empty_outputs:
       ensure(output)
     else:
       print("[ERROR] Archive does not contain file with extname: %s" % extname)
 
diff --git a/bazel/emscripten_toolchain/wasm_cc_binary.bzl b/bazel/emscripten_toolchain/wasm_cc_binary.bzl
index 6ea4f12..076357d 100644
--- a/bazel/emscripten_toolchain/wasm_cc_binary.bzl
+++ b/bazel/emscripten_toolchain/wasm_cc_binary.bzl
@@ -52,180 +52,202 @@ _wasm_transition = transition(
         "//command_line_option:cpu",
         "//command_line_option:crosstool_top",
         "//command_line_option:features",
         "//command_line_option:dynamic_mode",
         "//command_line_option:linkopt",
         "//command_line_option:platforms",
         "//command_line_option:custom_malloc",
     ],
 )
 
 _ALLOW_OUTPUT_EXTNAMES = [
     ".js",
     ".wasm",
     ".wasm.map",
     ".worker.js",
     ".js.mem",
     ".data",
     ".fetch.js",
     ".js.symbols",
     ".wasm.debug.wasm",
+    ".wasm.dwp",
     ".html",
     ".aw.js",
 ]
 
 _WASM_BINARY_COMMON_ATTRS = {
     "backend": attr.string(
         default = "_default",
         values = ["_default", "emscripten", "llvm"],
     ),
     "cc_target": attr.label(
         cfg = _wasm_transition,
         mandatory = True,
     ),
     "exit_runtime": attr.bool(
         default = False,
     ),
     "threads": attr.string(
         default = "_default",
         values = ["_default", "emscripten", "off"],
     ),
     "simd": attr.bool(
         default = False,
     ),
     "standalone": attr.bool(
         default = False,
     ),
     "_allowlist_function_transition": attr.label(
         default = "@bazel_tools//tools/allowlists/function_transition_allowlist",
     ),
     "_wasm_binary_extractor": attr.label(
         executable = True,
         allow_files = True,
         cfg = "exec",
         default = Label("@emsdk//emscripten_toolchain:wasm_binary"),
     ),
 }
 
 def _wasm_cc_binary_impl(ctx):
-    args = ctx.actions.args()
     cc_target = ctx.attr.cc_target[0]
+    dwp_file = cc_target[DebugPackageInfo].dwp_file if DebugPackageInfo in cc_target else None
+    outputs = ctx.outputs.outputs
 
-    for output in ctx.outputs.outputs:
+    for output in outputs:
         valid_extname = False
         for allowed_extname in _ALLOW_OUTPUT_EXTNAMES:
             if output.path.endswith(allowed_extname):
                 valid_extname = True
                 break
         if not valid_extname:
             fail("Invalid output '{}'. Allowed extnames: {}".format(output.basename, ", ".join(_ALLOW_OUTPUT_EXTNAMES)))
 
+    inputs = ctx.files.cc_target
+    args = ctx.actions.args()
     args.add_all("--archive", ctx.files.cc_target)
-    args.add_joined("--outputs", ctx.outputs.outputs, join_with = ",")
+    args.add_joined("--outputs", outputs, join_with = ",")
+
+    if dwp_file:
+        args.add("--dwp_file", dwp_file)
+        inputs = inputs + [dwp_file]
 
     ctx.actions.run(
-        inputs = ctx.files.cc_target,
-        outputs = ctx.outputs.outputs,
+        inputs = inputs,
+        outputs = outputs,
         arguments = [args],
         executable = ctx.executable._wasm_binary_extractor,
     )
 
     return [
         DefaultInfo(
-            files = depset(ctx.outputs.outputs),
+            files = depset(outputs),
             # This is needed since rules like web_test usually have a data
             # dependency on this target.
-            data_runfiles = ctx.runfiles(transitive_files = depset(ctx.outputs.outputs)),
+            data_runfiles = ctx.runfiles(transitive_files = depset(outputs)),
         ),
         OutputGroupInfo(_wasm_tar = cc_target.files),
     ]
 
 def _wasm_cc_binary_legacy_impl(ctx):
     cc_target = ctx.attr.cc_target[0]
+    dwp_file = cc_target[DebugPackageInfo].dwp_file if DebugPackageInfo in cc_target else None
     outputs = [
         ctx.outputs.loader,
         ctx.outputs.wasm,
         ctx.outputs.map,
         ctx.outputs.mem,
         ctx.outputs.fetch,
         ctx.outputs.worker,
         ctx.outputs.data,
         ctx.outputs.symbols,
         ctx.outputs.dwarf,
+        ctx.outputs.dwp,
         ctx.outputs.html,
         ctx.outputs.audio_worklet,
     ]
 
+    inputs = ctx.files.cc_target
     args = ctx.actions.args()
     args.add("--allow_empty_outputs")
     args.add_all("--archive", ctx.files.cc_target)
     args.add_joined("--outputs", outputs, join_with = ",")
 
+    if dwp_file:
+        args.add("--dwp_file", dwp_file)
+        inputs = inputs + [dwp_file]
+
+    py_toolchain = ctx.toolchains["@bazel_tools//tools/python:toolchain_type"]
+    python_path = py_toolchain.py3_runtime.interpreter.path
+    env = dict(ctx.configuration.default_shell_env)
+    env["PATH"] = "%s:/usr/bin:/bin" % python_path.rpartition("/")[0]
     ctx.actions.run(
-        inputs = ctx.files.cc_target,
+        inputs = inputs + [py_toolchain.py3_runtime.interpreter],
         outputs = outputs,
-        arguments = [args],
         executable = ctx.executable._wasm_binary_extractor,
+        arguments = [args],
+        env = env,
     )
 
     return [
         DefaultInfo(
             executable = ctx.outputs.wasm,
             files = depset(outputs),
             # This is needed since rules like web_test usually have a data
             # dependency on this target.
             data_runfiles = ctx.runfiles(transitive_files = depset(outputs)),
         ),
         OutputGroupInfo(_wasm_tar = cc_target.files),
     ]
 
 _wasm_cc_binary = rule(
     implementation = _wasm_cc_binary_impl,
     attrs = dict(
         _WASM_BINARY_COMMON_ATTRS,
         outputs = attr.output_list(
             allow_empty = False,
             mandatory = True,
         ),
     ),
 )
 
 def _wasm_binary_legacy_outputs(name, cc_target):
     basename = cc_target.name
     basename = basename.split(".")[0]
     outputs = {
         "loader": "{}/{}.js".format(name, basename),
         "wasm": "{}/{}.wasm".format(name, basename),
         "map": "{}/{}.wasm.map".format(name, basename),
         "mem": "{}/{}.js.mem".format(name, basename),
         "fetch": "{}/{}.fetch.js".format(name, basename),
         "worker": "{}/{}.worker.js".format(name, basename),
         "data": "{}/{}.data".format(name, basename),
         "symbols": "{}/{}.js.symbols".format(name, basename),
         "dwarf": "{}/{}.wasm.debug.wasm".format(name, basename),
+        "dwp": "{}/{}.wasm.dwp".format(name, basename),
         "html": "{}/{}.html".format(name, basename),
         "audio_worklet": "{}/{}.aw.js".format(name, basename)
     }
 
     return outputs
 
 _wasm_cc_binary_legacy = rule(
     implementation = _wasm_cc_binary_legacy_impl,
     attrs = _WASM_BINARY_COMMON_ATTRS,
     outputs = _wasm_binary_legacy_outputs,
+    toolchains = ["@bazel_tools//tools/python:toolchain_type"],
 )
 
 # Wraps a C++ Blaze target, extracting the appropriate files.
 #
 # This rule will transition to the emscripten toolchain in order
 # to build the the cc_target as a WebAssembly binary.
 #
 # Args:
 #   name: The name of the rule.
 #   cc_target: The cc_binary or cc_library to extract files from.
 def wasm_cc_binary(outputs = None, **kwargs):
     # for backwards compatibility if no outputs are set the deprecated
     # implementation is used.
     if not outputs:
         _wasm_cc_binary_legacy(**kwargs)
     else:
         _wasm_cc_binary(outputs = outputs, **kwargs)
