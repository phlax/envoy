#!/usr/bin/env bash
#
# A git commit hook that will automatically run format checking and DCO signoff
# checking before the push is successful.
#
# To enable this hook, run `bootstrap`, or run the following from the root of
# the repo. (Note that `bootstrap` will correctly install this even if this code
# is located in a submodule, while the following won't.)
#
# $ ln -s ../../support/hooks/pre-push .git/hooks/pre-push

DUMMY_SHA=0000000000000000000000000000000000000000

echo "Running pre-push check; to skip this step use 'push --no-verify' or check support/hooks/README.md for more info"

CHECKS=(
    "code_format:*"
    "glint:*"
    "shellcheck:*"
    "flake8:*.py"
    "python_autoformat:*.py"
    "spelling:*"
    "protos:*.proto"
    "repositories:*.bzl")

DEBUG="${DEBUG_COMMIT_PUSH:-}"
FLAKE8_PATH=${FLAKE_PATH:-$(which flake8)}
SHELLCHECK_PATH=${FLAKE_PATH:-$(which shellcheck)}

# skip message/logic for code_format
SKIP_CODE_FORMAT="${SKIP_CODE_FORMAT:-}"
CODE_FORMAT_PROBLEM="WARNING: Missing \$BUILDIFIER_PATH or \$CLANG_FORMAT, skipping code_format/check_format.py"
CODE_FORMAT_SOLUTION="See https://github.com/envoyproxy/envoy/blob/main/bazel/README.md#running-clang-format-without-docker for further information"

# skip message/logic for autoformat
SKIP_PYTHON_AUTOFORMAT="${SKIP_PYTHON_AUTOFORMAT:-}"

# skip message/logic for flake8
SKIP_FLAKE8="${SKIP_FLAKE8:-}"
FLAKE8_PROBLEM="WARNING: Missing flake8 command in \$PATH"
FLAKE8_SOLUTION="Install flake8 using pip."

# skip message/logic for shellcheck
SKIP_SHELLCHECK="${SKIP_SHELLCHECK:-}"
SHELLCHECK_PROBLEM="WARNING: Missing flake8 command in \$PATH"
SHELLCHECK_SOLUTION="Install shellcheck for your system."

# skip logic for protos
SKIP_PROTOS="${SKIP_PROTOS:-}"

# NOTE: The `tools` directory will be the same relative to the support
# directory, independent of whether we're in a submodule, so no need to use
# our `relpath` helper.
SRC_DIR="$(dirname "$(realpath "$0")")/../../"
SCRIPT_DIR="${SRC_DIR}/tools"

SHEBANG_RE='^#!/bin/bash|^#!/bin/sh|^#!/usr/bin/env bash'


if [[ -f "${SRC_DIR}/.envoypush" ]]; then
    # allow user to override paths and/or suppress checks and error messages with env vars
    # shellcheck disable=SC1090
    . "${SRC_DIR}/.envoypush"
fi


check_dco () {
    # Verify DCO signoff. We do this before the format checker, since it has
    # some probability of failing spuriously, while this check never should.
    #
    # In general, we can't assume that the commits are signed off by author
    # pushing, so we settle for just checking that there is a signoff at all.
    # check all commits that would be added have been signed
    local range="$1" signed_off not_signed_off

    signed_off=$(git rev-list --no-merges --grep "^Signed-off-by: " "$range")
    not_signed_off=$(git rev-list --no-merges "$range" | grep -Fxv "$signed_off")
    if [ -n "$not_signed_off" ]; then
        echo >&2 "ERROR: The following commits do not have DCO signoff:"
        while read -r commit; do
            echo "  $(git log --pretty=oneline --abbrev-commit -n 1 "$commit")"
        done <<< "$not_signed_off"
        exit 1
    fi
}

check_code_format () {
    # Clang tidy
    # not sure if we could filter the filetypes that are hit here
    local file="$1"
    if [[ -n "$SKIP_CODE_FORMAT" ]]; then
        return
    fi
    [[ -n "$DEBUG" ]] && echo "code_format: ${file}"
    if [[ -n "$BUILDIFIER_PATH" ]] && [[ -n "$CLANG_FORMAT" ]];  then
        echo -ne "  Checking format for ${file} - "
        "$SCRIPT_DIR"/code_format/check_format.py check "$file" || exit 1
    else
        echo -e "\n  $CODE_FORMAT_PROBLEM\n" >&2
        echo -e "\n  $CODE_FORMAT_SOLUTION\n" >&2
        SKIP_CODE_FORMAT=yes
    fi
}

check_flake8 () {
    # Flake8 python files
    local file="$1"
    if [[ -n "$SKIP_FLAKE8" ]]; then
        return
    fi
    [[ -n "$DEBUG" ]] && echo "flake8: ${file}"
    if [[ -n "$FLAKE8_PATH" ]];  then
        "$FLAKE8_PATH" "$i" || exit 1
    else
        echo -e "\n  $FLAKE8_PROBLEM\n" >&2
        echo -e "\n  $FLAKE8_SOLUTION\n" >&2
        SKIP_FLAKE8=yes
    fi
}

check_protos () {
    # Run proto_format.sh
    # it only runs once and only if a .proto file is found to be changed
    if [[ -n "$SKIP_PROTOS" ]]; then
        return
    fi
    "$SCRIPT_DIR"/proto_format/proto_format.sh check || exit 1
    # TODO(mattklein123): Optimally we would be able to do this on a per-file basis.
    # only run this once - this is a half-workaround for now
    SKIP_PROTOS=yes
}

check_shellcheck () {
    # Run shellcheck on files with .sh suffix or shebang lines
    local file="$1" isshell=
    if [[ -n "$SKIP_SHELLCHECK" ]]; then
        return
    fi
    if [[ ${file: -3} == ".sh" ]]; then
        isshell=yes
    elif grep -E "$SHEBANG_RE" "$file" > /dev/null; then
        isshell=yes
    fi
    if [[ -z "$isshell" ]]; then
        return
    fi
    [[ -n "$DEBUG" ]] && echo "shellcheck: ${file}"
    if [[ -n "$SHELLCHECK_PATH" ]];  then
        "$SHELLCHECK_PATH" -x "$i" || exit 1
    else
        echo -e "\n  $SHELLCHECK_PROBLEM\n" >&2
        echo -e "\n  $SHELLCHECK_SOLUTION\n" >&2
        SKIP_SHELLCHECK=yes
    fi
}

check_glint () {
    # Run glint on all files to ensure general formatting compliance
    local file="$1"
    [[ -n "$DEBUG" ]] && echo "glint: ${file}"
    "$SCRIPT_DIR"/code_format/glint.sh "$1"
}


check_python_autoformat () {
    # Run python autoformatter
    local file="$1"
    if [[ -n "$SKIP_PYTHON_AUTOFORMAT" ]]; then
        return
    fi
    "$SCRIPT_DIR"/code_format/format_python_tools.sh check "$file" || :
}

check_spelling () {
    # Run spellcheck
    local file="$1"
    [[ -n "$DEBUG" ]] && echo "spelling: ${file}"
    "$SCRIPT_DIR"/spelling/check_spelling_pedantic.py check "$file" || exit 1
}

check_repositories () {
    # Check repo dependency rules
    local file="$1"
    # Check correctness of repositories definitions.
    [[ -n "$DEBUG" ]] && echo "repositories: ${file}"
    "$SCRIPT_DIR"/check_repositories.sh "$1" || exit 1
}


while read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
    export LOCAL_REF REMOTE_REF
    if [ "$LOCAL_SHA" = $DUMMY_SHA ];  then
        # Branch deleted. Do nothing.
        exit 0
    else
        if [ "$REMOTE_SHA" = $DUMMY_SHA ]; then
            # New branch. Verify the last commit, since this is very likely where the new code is
            # (though there is no way to know for sure). In the extremely uncommon case in which someone
            # pushes more than 1 new commit to a branch, CI will enforce full checking.
            RANGE="$LOCAL_SHA~1..$LOCAL_SHA"
        else
            # Updating branch. Verify new commits.
            RANGE="$REMOTE_SHA..$LOCAL_SHA"
        fi

        # Run the checks
        check_dco "$RANGE"
        for i in $(git diff --name-only "$RANGE" --diff-filter=ACMR --ignore-submodules=all 2>&1); do
            for checkinfo in "${CHECKS[@]}"; do
                read -ra check <<< "${checkinfo//:/ }"
                if echo "$i" | grep -E "${check[1]}" > /dev/null; then
                    "check_${check[0]}" "$i"
                fi
            done
        done
    fi
done
