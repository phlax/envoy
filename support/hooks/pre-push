#!/usr/bin/env bash
#
# A git commit hook that will automatically run format checking and DCO signoff
# checking before the push is successful.
#
# To enable this hook, run `bootstrap`, or run the following from the root of
# the repo. (Note that `bootstrap` will correctly install this even if this code
# is located in a submodule, while the following won't.)
#
# $ ln -s ../../support/hooks/pre-push .git/hooks/pre-push

DUMMY_SHA=0000000000000000000000000000000000000000

# Set non-empty value to quieten push hook
SKIP_PUSH_MESSAGE=

# Link to README in the repo
# TODO(phlax): Update to main
README_URL=https://github.com/envoyproxy/envoy/blob/2ff6c360fe80c84de846c5211fe42e594f1c734c/support/hooks/README.md

PUSH_MESSAGE=(
    "Running pre-push checks"
    "* You can skip this step with \"git push --no-verify\""
    "* More info here: ${README_URL}"
    "* Hide this message with \"echo SKIP_PUSH_MESSAGE=yes >> .envoypush\"")

# this is a list of checks that are run
# the check is split on the first colon
# - the function to run ie - `check_{check_name}`
# - a regex to match the filename
CHECKS=(
    "code_format:BUILD$|WORKSPACE$|\.bzl$|\.cc$|\.h$|\.java$|\.m$|\.md$|\.mm$|\.proto$|\.rst$"
    "glint:*"
    "shellcheck:*"
    "flake8:\.py$"
    "yapf:\.py$"
    "spelling:\.cc$|\.h$|\.proto$"
    "protos:\.proto$"
    "repositories:\.bzl$")

DEBUG="${DEBUG_COMMIT_PUSH:-}"

# handle failure
EXIT_ON_ERROR="${EXIT_ON_ERROR:-}"
FAIL_ON_MISSING="${FAIL_ON_MISSING:-}"
PUSH_ON_FAILURE="${PUSH_ON_FAILURE:-}"
FAILED=

# DCO
DCO_ERROR_COMMITS=(
    "ERROR: The following commits do not have DCO signoff:"
    ""
    "See here for information on how to fix")

# skip message/logic for code_format
SKIP_CODE_FORMAT="${SKIP_CODE_FORMAT:-}"
CODE_FORMAT_WARNING=(
    "WARNING: Skipping code_format checks - missing \$BUILDIFIER_PATH or \$CLANG_FORMAT"
    ""
    "    See https://github.com/envoyproxy/envoy/blob/main/bazel/README.md#running-clang-format-without-docker for further information")

# skip message/logic for flake8
FLAKE8_PATH=${FLAKE8_PATH:-$(command -v flake8)}
FLAKE8_WARNING=(
    "WARNING: Missing flake8 command in \$PATH"
    ""
    "    Install flake8 using pip.")
SKIP_FLAKE8="${SKIP_FLAKE8:-}"

# skip message/logic for shellcheck
SHELLCHECK_PATH=${SHELLCHECK_PATH:-$(command -v shellcheck)}
SHELLCHECK_WARNING=(
    "WARNING: Missing shellcheck command in \$PATH"
    ""
    "    Install shellcheck for your system.")
SKIP_SHELLCHECK="${SKIP_SHELLCHECK:-}"

# skip logic for protos - requires bazel
SKIP_PROTOS="${SKIP_PROTOS:-}"
BAZEL_PATH=${BAZEL_PATH:-$(command -v bazel)}
PROTOS_WARNING=(
    "WARNING: Missing bazel command in \$PATH"
    ""
    "    Install bazel for your system.")

# skip message/logic for yapf
YAPF_PATH=${YAPF_PATH:-$(command -v yapf)}
YAPF_WARNING=(
    "WARNING: Missing yapf command in \$PATH"
    ""
    "    Install yapf using pip.")
SKIP_YAPF="${SKIP_YAPF:-}"

# NOTE: The `tools` directory will be the same relative to the support
# directory, independent of whether we're in a submodule, so no need to use
# our `relpath` helper.
SRC_DIR="$(dirname "$(realpath "$0")")/../../"
SCRIPT_DIR="${SRC_DIR}/tools"

SHEBANG_RE='^#!/bin/bash|^#!/bin/sh|^#!/usr/bin/env bash'


if [[ -f "${SRC_DIR}/.envoypush" ]]; then
    # allow user to override paths and/or suppress checks and error messages with env vars
    # shellcheck disable=SC1090
    . "${SRC_DIR}/.envoypush"
fi


check_dco () {
    # Verify DCO signoff. We do this before the format checker, since it has
    # some probability of failing spuriously, while this check never should.
    #
    # In general, we can't assume that the commits are signed off by author
    # pushing, so we settle for just checking that there is a signoff at all.
    # check all commits that would be added have been signed
    local range="$1" signed_off not_signed_off

    log_check dco
    signed_off=$(git rev-list --no-merges --grep "^Signed-off-by: " "$range")
    not_signed_off=$(git rev-list --no-merges "$range" | grep -Fxv "$signed_off")
    if [[ -n "$not_signed_off" ]]; then
        log_error dco "${DCO_ERROR_COMMITS[@]}"
        while read -r commit; do
            echo "  $(git log --pretty=oneline --abbrev-commit -n 1 "$commit")"
        done <<< "$not_signed_off"
        handle_error dco
    fi
}

check_code_format () {
    # Clang tidy a file
    #
    local file="$1"
    if [[ -n "$SKIP_CODE_FORMAT" ]]; then
        return
    fi
    log_check code_format "$file"
    if [[ -n "$BUILDIFIER_PATH" ]] && [[ -n "$CLANG_FORMAT" ]];  then
        "$SCRIPT_DIR"/code_format/check_format.py check "$file" || handle_error code_format
    else
        handle_missing code_format "${CODE_FORMAT_WARNING[@]}"
        SKIP_CODE_FORMAT=yes
    fi
}

check_flake8 () {
    # Flake8 a python file
    local file="$1"
    if [[ -n "$SKIP_FLAKE8" ]]; then
        return
    fi
    log_check flake8 "$file"
    if [[ -n "$FLAKE8_PATH" ]];  then
        "$FLAKE8_PATH" "$file" || handle_error flake8
    else
        handle_missing flake8 "${FLAKE8_WARNING[@]}"
        SKIP_FLAKE8=yes
    fi
}

check_protos () {
    # Run proto_format.sh
    # this only runs once and only if a .proto file is found to be changed
    #
    if [[ -n "$SKIP_PROTOS" ]]; then
        return
    fi
    log_check protos "$file"

    # TODO(mattklein123): Optimally we would be able to do this on a per-file basis.
    # only run this once - this is a half-workaround for now
    SKIP_PROTOS=yes

    if [[ -n "$BAZEL_PATH" ]];  then
        "$SCRIPT_DIR"/proto_format/proto_format.sh check || handle_error protos
    else
        handle_missing protos "${PROTOS_WARNING[@]}"
    fi
}

check_shellcheck () {
    # Run shellcheck on a file with .sh suffix or shebang lines
    local file="$1" isshell=
    if [[ -n "$SKIP_SHELLCHECK" ]]; then
        return
    fi
    if [[ ${file: -3} == ".sh" ]]; then
        isshell=yes
    elif grep -E "$SHEBANG_RE" "$file" > /dev/null; then
        isshell=yes
    fi
    if [[ -z "$isshell" ]]; then
        return
    fi
    log_check shellcheck "$file"
    if [[ -n "$SHELLCHECK_PATH" ]];  then
        "$SHELLCHECK_PATH" -x "$file" || handle_error shellcheck
    else
        handle_missing shellcheck "${SHELLCHECK_WARNING[@]}"
        SKIP_SHELLCHECK=yes
    fi
}

check_glint () {
    # Run glint on a file to ensure general formatting compliance
    local file="$1"
    log_check glint "$file"
    "$SCRIPT_DIR"/code_format/glint.sh "$1" || handle_error glint
}

check_yapf () {
    # Run yapf on a file
    local file="$1"
    if [[ -n "$SKIP_YAPF" ]]; then
        return
    fi
    log_check yapf "$file"
    if [[ -n "$YAPF_PATH" ]];  then
        "$SCRIPT_DIR/code_format/format_python_tools.py" check "$file" || handle_error yapf
    else
        handle_missing yapf "${YAPF_WARNING[@]}"
        SKIP_YAPF=yes
    fi
}

check_spelling () {
    # Run spelling checks on a file
    local file="$1"
    if [[ -n "$SKIP_SPELLING" ]]; then
        return
    fi
    # TODO(phlax): add check for aspell
    log_check spelling "$file"
    "$SCRIPT_DIR"/spelling/check_spelling_pedantic.py check "$file" || handle_error spelling
}

check_repositories () {
    # Check repo dependency rules in a bazel file
    local file="$1"
    log_check repositories "$file"
    # This just uses grep atm so has no dependencies itself
    "$SCRIPT_DIR"/check_repositories.sh "$1" || handle_error repositories
}

handle_missing () {
    local missing="$1"
    log_error "${@}"
    if [[ -n "$FAIL_ON_MISSING" ]]; then
        log_error "$missing" "ERROR: missing util"
        handle_error "$missing"
    fi
}

handle_error () {
    local failure="$1"
    FAILED=yes
    if [[ -n "$EXIT_ON_ERROR" ]]; then
        log_error "$failure" "FAILED"
        exit 1
    fi
}

log_check () {
    if [[ -z "$DEBUG" ]]; then
        return
    fi
    echo "[check:${1}] ${2}"
}

log_error () {
    local check="$1"
    shift
    echo "[check:${check}]" >&2
    for line in "${@}"; do
        echo "[check:${check}] ${line}" >&2
    done
    echo "[check:${check}]" >&2
}


if [[ -z "$SKIP_PUSH_MESSAGE" ]]; then
    echo
    for line in "${PUSH_MESSAGE[@]}"; do
        echo "    $line"
        echo
    done
fi

while read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
    export LOCAL_REF REMOTE_REF
    if [[ "$LOCAL_SHA" = "$DUMMY_SHA" ]];  then
        # Branch deleted. Do nothing.
        exit 0
    else
        if [[ "$REMOTE_SHA" = "$DUMMY_SHA" ]]; then
            # New branch. Verify the last commit, since this is very likely where the new code is
            # (though there is no way to know for sure). In the extremely uncommon case in which someone
            # pushes more than 1 new commit to a branch, CI will enforce full checking.
            RANGE="$LOCAL_SHA~1..$LOCAL_SHA"
        else
            # Updating branch. Verify new commits.
            RANGE="$REMOTE_SHA..$LOCAL_SHA"
        fi

        # Run the checks
        check_dco "$RANGE"
        for filepath in $(git diff --name-only "$RANGE" --diff-filter=ACMR --ignore-submodules=all 2>&1); do

            # run each check against the file where the check's regex matches for the filepath
            for checkinfo in "${CHECKS[@]}"; do
                read -ra check <<< "${checkinfo//:/ }"
                if echo "$filepath" | grep -E "${check[1]}" > /dev/null; then
                    "check_${check[0]}" "$filepath"
                fi
            done
        done

        # If push on failure is *not* set and there are errors, exit 1
        if [[ -z "$PUSH_ON_FAILURE" ]] && [[ -n "$FAILED" ]]; then
            exit 1
        fi
    fi
done
